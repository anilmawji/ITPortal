@page "/script-executor"

@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System.Management.Automation;
@using System.Diagnostics;
@using ITPortal.Lib.Services.Automation;
@using ITPortal.Lib.Services.Core;
@using ITPortal.Lib.Utilities;
@using System.Management.Automation.Runspaces;
@using ITPortal.Lib.Services.Automation.Script;

@inject IScriptOutputStreamService PowerShellService

@*@attribute [Authorize]*@

@*<button @onclick="PickAndLoadScript">Choose file</button>

@if (_script != null)
{
    @if (_script.Parameters != null)
    {
        <hr>
        <p>Parameters:</p>

        <EditForm Model="@_script.Parameters" OnSubmit="@RunScript">
            <div class="form-group">
                <button type="submit" class="btn btn-primary" disabled="@(!_script.Loaded || _scriptRunning)">Run</button>
            </div>

            @foreach (var parameter in _script.Parameters)
            {
                // Cannot use two-way binding for these since parameter.Value is an object and must be casted to the correct type
                @if (parameter.DesiredType == typeof(string))
                {
                    <MudTextField T="string" Label="@parameter.Name" Required="@parameter.Mandatory"
                        Text="@((string)parameter.Value)" TextChanged="(text) => parameter.Value = text" />
                }
                else if (parameter.DesiredType == typeof(int))
                {
                    <MudNumericField T="int" Label="@parameter.Name" Required="@parameter.Mandatory"
                        Value="@((int)parameter.Value)" ValueChanged="(num) => parameter.Value = num" />
                }
                else if (parameter.DesiredType == typeof(bool))
                {
                    <MudSwitch T="bool" Label="@parameter.Name" Required="@parameter.Mandatory"
                        Checked="@((bool)parameter.Value)" CheckedChanged="(checkedValue) => parameter.Value = checkedValue" />
                }
                else if (parameter.DesiredType == typeof(DateTime))
                {
                    // No need to explicitly update "date" since it references parameter.Value which is being updated every time the date changes
                    DateTime date = (DateTime)parameter.Value;
                    TimeSpan time = date.TimeOfDay;

                    <MudDatePicker Label="@parameter.Name" Required="@parameter.Mandatory" PickerVariant="PickerVariant.Inline"
                        Date="@date" DateChanged="(newDate) => OnDateChanged((DateTime)newDate, time, parameter)" />
                    <MudTimePicker AmPm="true" Time="@time" TimeChanged="(newTime) => time = OnTimeChanged((TimeSpan)newTime, date, parameter)" />
                }
                else if (parameter.DesiredType == typeof(string[]))
                {
                    <MudExtensions.MudChipField T="string" Label="@parameter.Name" Required="@parameter.Mandatory" Values="@((List<string>)parameter.Value)"
                        Delimiter="_delimiter" FullWidth="_fullWidth" ChipColor="_color" ChipVariant="_chipVariant" ChipSize="_chipSize" WrapChips="_wrapChips"
                        ChipsMaxWidth="_chipsMaxWidth" Closeable="_closeable" Variant="_variant" />
                }
                else if (parameter.DesiredType == typeof(int[]))
                {
                    <MudExtensions.MudChipField T="int" Label="@parameter.Name" Required="@parameter.Mandatory" Values="@((List<string>)parameter.Value)"
                        Delimiter="_delimiter" FullWidth="_fullWidth" ChipColor="_color" ChipVariant="_chipVariant" ChipSize="_chipSize" WrapChips="_wrapChips"
                        ChipsMaxWidth="_chipsMaxWidth" Closeable="_closeable" Variant="_variant" />
                }
                else if (parameter.DesiredType == typeof(bool[]))
                {
                    <MudExtensions.MudChipField T="bool" Label="@parameter.Name" Required="@parameter.Mandatory" Values="@((List<string>)parameter.Value)"
                        Delimiter="_delimiter" FullWidth="_fullWidth" ChipColor="_color" ChipVariant="_chipVariant" ChipSize="_chipSize"
                        WrapChips="_wrapChips" ChipsMaxWidth="_chipsMaxWidth" Closeable="_closeable" Variant="_variant" />
                }
                else
                {
                    <p>Parameter @parameter.Name is not supported</p>
                }
            }
        </EditForm>
    }
    else if (_script.Loaded)
    {
        <div class="form-group">
            <button class="btn btn-primary" disabled="@(!_script.Loaded || _scriptRunning)">Run</button>
        </div>

        <p>No parameters found</p>
    }

    <button @onclick="CancelRunScript" class="btn btn-primary" disabled="@(!_scriptRunning)">Cancel</button>

    @if (_script.Loaded)
    {
        <div class="form-group">
            <button @onclick="() => LoadScript()" class="btn btn-primary">Refresh</button>
            <button @onclick="EditScript" class="btn btn-primary">Edit</button>
            <button @onclick="RemoveScript" class="btn btn-primary">Remove</button>
        </div>
    }
}

<hr background-color="black" color="black" border="none">

@*Use standard for loop to avoid "Collection Was Modified error" caused by
  invalidating the iterator by adding elements while iterating (foreach has an implicit iterator)*@ 
@for (int i = 0; i < PowerShellService.Output.Count(); i++)
{
    var psMessage = PowerShellService.Output[i];

    <div class="@psMessage.Stream">
        @((MarkupString)psMessage.Data)
    </div>
}

@code {
    //// MudChipField settings
    //private readonly char _delimiter = ' ';
    //private readonly int _chipsMaxWidth = 80;
    //private readonly Color _color = Color.Default;
    //private readonly Variant _chipVariant = Variant.Filled;
    //private readonly Variant _variant = Variant.Text;
    //private readonly Size _chipSize = Size.Medium;
    //private readonly bool _fullWidth = true;
    //private readonly bool _wrapChips = true;
    //private readonly bool _closeable = true;

    //private FilePickerFileType _psFileType;
    //private PickOptions _pickOptions;
    //private PowerShellScript _script;
    //private CancellationTokenSource _cancellationTokenSource;
    //private bool _scriptRunning;

    //protected override void OnInitialized()
    //{
    //    _psFileType = new(new Dictionary<DevicePlatform, IEnumerable<string>>
    //        {
    //            { DevicePlatform.WinUI, new[] { ".ps1" } },
    //            { DevicePlatform.macOS, new[] { "ps1" } }
    //        }
    //    );
    //    _pickOptions = new()
    //    {
    //        // PickerTitle is used by macOS but not Windows - unreliable way of informing user
    //        PickerTitle = "Please select a PowerShell _script file",
    //        FileTypes = _psFileType,
    //    };
    //    _script = new PowerShellScript(PowerShellService);

    //    PowerShellService.OutputChanged += (object sender, List<ScriptOutputMessage> newOutput) =>
    //    {
    //        InvokeAsync(() => this.StateHasChanged());
    //    };
    //}

    //private void OnDateChanged(DateTime newDate, TimeSpan time, ScriptParameter parameter)
    //{
    //    parameter.Value = newDate.Date.Add(time);
    //}

    //private TimeSpan OnTimeChanged(TimeSpan newTime, DateTime date, ScriptParameter parameter)
    //{
    //    parameter.Value = date.Date.Add(newTime);

    //    return newTime;
    //}

    //private async void PickAndLoadScript()
    //{
    //    var fileResult = await FilePickerHandler.PickFile(_pickOptions);

    //    if (fileResult != null)
    //    {
    //        LoadScript(fileResult.FullPath);
    //    }
    //}

    //private void LoadScript(string filePath = null)
    //{
    //    if (_scriptRunning) CancelRunScript();
    //    PowerShellService.Output.Clear();

    //    var loaded = filePath != null ? _script.Load(filePath) : _script.Refresh();

    //    if (loaded)
    //    {
    //        this.StateHasChanged();
    //    }
    //    else
    //    {
    //        PowerShellService.AddOutput("Error loading _script");
    //        PowerShellService.AddOutput("<hr width=\"300px\" height=\"1px\"><b>EXECUTION FAILED</b>");
    //    }
    //}

    //private async void RunScript()
    //{
    //    if (_scriptRunning) CancelRunScript();
    //    PowerShellService.Output.Clear();

    //    _cancellationTokenSource = new();
    //    _cancellationTokenSource.Token.Register(() =>
    //    {
    //        _scriptRunning = false;
    //        PowerShellService.AddOutput("<hr width=\"300px\" height=\"1px\"><b>EXECUTION CANCELLED</b>");
    //    });

    //    PowerShellService.AddOutput("<b>BEGIN</b><hr width=\"300px\" height=\"1px\">");

    //    _scriptRunning = true;
    //    await _script.InvokeAsync(_cancellationTokenSource.Token, "Script execution cancelled");

    //    _scriptRunning = false;

    //    if (!_cancellationTokenSource.IsCancellationRequested)
    //    {
    //        PowerShellService.AddOutput("<hr width=\"300px\" height=\"1px\"><b>EXECUTION COMPLETE</b>");
    //    }
    //}

    //private void CancelRunScript()
    //{
    //    _scriptRunning = false;
    //    _cancellationTokenSource.Cancel();
    //}

    //private void RemoveScript()
    //{
    //    if (_scriptRunning) CancelRunScript();
    //    PowerShellService.Output.Clear();

    //    _script = new PowerShellScript(PowerShellService);

    //    this.StateHasChanged();
    //}

    //private void EditScript()
    //{
    //    if (!_script.Loaded || _script.FilePath == null) return;
        
    //    FileHandler.OpenFileWithDefaultProgram(_script.FilePath);
    //}
}