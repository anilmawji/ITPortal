@attribute [Route(PageRoute.ScriptJobResultDetails)]

@inject NavigationManager NavigationManager

@inherits ScriptJobResultBase

<PageContainer Title="PowerShell Job Results" NestedTitle=@($"Result {Result.Id}") PreviousPage="/job-results">
    <div class="script-title">
        <p>Script: @Result.ScriptName</p>
        <div class="title-chip">
            <ScriptExecutionStateChipText Result=@Result OnResultReceived=@(() => InvokeAsync(this.StateHasChanged))/>
        </div>
    </div>
    <div class="section">
        <p>Execution Time: @Result.ExecutionTime</p>
        <p>Device: @Result.DeviceName</p>
        <p>Job Name: @Result.JobName</p>
    </div>
    <div class="section">
        <MudGrid Spacing="2">
            <MudItem>
                <MudButton @onclick=@Job.Cancel Variant="Variant.Filled" Color="Color.Secondary"
                           Style="color:white" Disabled=@(Job == null || Result.ExecutionState != ScriptExecutionState.Running)>
                    <MudText>Cancel</MudText>
                </MudButton>
            </MudItem>
            <MudItem>
                <MudButton @onclick=@GoToEditJob Variant="Variant.Filled" Color="Color.Secondary" Style="color:white" Disabled=@(Job == null)>
                    <MudText>Edit Job</MudText>
                </MudButton>
            </MudItem>
        </MudGrid>
    </div>
    <ScriptOutputTabs ScriptOutput=@Result.ScriptOutput @ref=@OutputTabs />
</PageContainer>

@code {
    ScriptJob Job;
    ScriptOutputTabs OutputTabs;

    protected override void OnInitialized()
    {
        // Very important to make sure ScriptJobResultBase is populated
        base.OnInitialized();

        Job = ScriptJobService.JobList.TryGetJob(Result.JobName);
    }

    private void GoToEditJob()
    {
        NavigationManager.NavigateTo(PageRoute.EditScriptJobWithName(Job.Name));
    }

    public void Dispose()
    {
        OutputTabs.Dispose();
    }
}
